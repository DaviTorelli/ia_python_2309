# -*- coding: utf-8 -*-
"""censo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aBdD8WLnk_3ZNC2OIoNarC4DdIud_WSJ

#Atualização e Importação de bibliotecas
"""

!pip -q install plotly --upgrade #atualizando a biblioteca plotly

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px

"""#Importação do Dataset"""

base_census = pd.read_csv('/content/census.csv')

"""#Exploração de Dados"""

base_census

#Variável Discreta: É tipo numérica, mas que não tem muitos (ou nenhum) números decimais. Exemplos: age, education-num, hour-per-week.
#Variável Contínua: É tipo numérica, que contém bastantes números decimais. Exemplos: Final-Weight, Capital-Gain, Capital-Loss
#Variável Categórica Nominal: Não demanda hierarquia para as categorias, são separadas por nome, mas nenhuma é superior à outra. Exemplo: Workclass, marital-status, relationship, race, sexo, native-country
#Variável Categórica Ordinal: Demanda uma ordem, sendo uma categoria superior ou dependente da outra. Exemplo: Education

base_census.describe() #descreve todos os valores numéricos da base de dados
base_census.isnull().sum() #verifica se existe algum valor nulo na base de dados

np.unique(base_census['income'], return_counts= True)

sns.countplot(x = base_census['income']);

plt.hist(x = base_census['hour-per-week']);

grafico = px.treemap(base_census, path=['occupation','relationship','age'])
grafico.show()

grafico = px.parallel_categories(base_census,
                                 dimensions=['occupation','relationship'])
grafico.show()

grafico = px.parallel_categories(base_census,
                                 dimensions=['education','income'])
grafico.show()

"""#Previsores e Classes"""

base_census.columns #gera todas as colunas da base de dados

X_census = base_census.iloc[:, 0:14].values

y_census = base_census.iloc[:,14].values

"""#Tratamento de atributos categóricos"""

from sklearn.preprocessing import LabelEncoder #importa a biblioteca LabelEncoder

label_encoder_teste = LabelEncoder()

X_census[:,1]

teste = label_encoder_teste.fit_transform(X_census[:,1]) #converte os rótulos que eram string para tipos numéricos, para variáveis discretas

#Criando um encoder para cada coluna que possui dados categóricos (não-numéricos) na base de dados
label_encoder_workclass = LabelEncoder()
label_encoder_education = LabelEncoder()
label_encoder_marital = LabelEncoder()
label_encoder_occupation = LabelEncoder()
label_encoder_relationship = LabelEncoder()
label_encoder_race = LabelEncoder()
label_encoder_sex = LabelEncoder()
label_encoder_country = LabelEncoder()

X_census[:,1] = label_encoder_workclass.fit_transform(X_census[:,1])
X_census[:,3] = label_encoder_education.fit_transform(X_census[:,3])
X_census[:,5] = label_encoder_marital.fit_transform(X_census[:,5])
X_census[:,6] = label_encoder_occupation.fit_transform(X_census[:,6])
X_census[:,7] = label_encoder_relationship.fit_transform(X_census[:,7])
X_census[:,8] = label_encoder_race.fit_transform(X_census[:,8])
X_census[:,9] = label_encoder_sex.fit_transform(X_census[:,9])
X_census[:,13] = label_encoder_country.fit_transform(X_census[:,13])

"""O problema do LabelEncoder, é que se houverem muitas categorias, serão convertidos em muitos números."""

len(np.unique(base_census['workclass']))

len(np.unique(base_census['occupation']))

from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
#OneHotEncoder - complemento do labelencoder

onehotencoder_census = ColumnTransformer(transformers=[('OneHot', OneHotEncoder(),
                                                        [1,3,5,6,7,8,9,13])], remainder='passthrough')

X_census = onehotencoder_census.fit_transform(X_census).toarray()

X_census.shape #mostra quantas linhas e coluna a variável X_census possui

"""#Escalonamento de valores"""

from sklearn.preprocessing import StandardScaler
scaler_census = StandardScaler()
X_census = scaler_census.fit_transform(X_census)

X_census[0]

"""#Divisão das bases em treinamento e teste"""

from sklearn.model_selection import train_test_split

X_census_treinamento, X_census_teste, y_census_treinamento, y_census_teste = train_test_split(X_census, y_census, test_size = 0.15, random_state = 0)

X_census_treinamento.shape, y_census_treinamento.shape

X_census_teste.shape, y_census_teste.shape

"""#Salvando as Variáveis"""

import pickle

with open('census.pkl', mode= 'wb') as f:
  pickle.dump([X_census_treinamento, y_census_treinamento, X_census_teste, y_census_teste], f)